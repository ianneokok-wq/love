<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Particle Heart with Ashiee!!</title>
<style>
  html,body { height:100%; margin:0; }
  body { margin:0; background:#000; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; }
  #hint {
    position: fixed;
    left: 12px;
    bottom: 12px;
    padding:8px 10px;
    border-radius:8px;
    background: rgba(255,255,255,0.06);
    color: white;
    font-size:13px;
    z-index: 9999;
    backdrop-filter: blur(6px);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hint">Tap/Click to re-form the heart • Open Console if blank</div>

<script>
(function () {
  'use strict';
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(window.devicePixelRatio || 1, 1);

  const CONFIG = {
    heartScale: 32,
    step: 0.005,
    particleMinSize: 0.9,
    particleMaxSize: 2.2,
    speedMin: 0.006,
    speedMax: 0.012,
    starCount: 240,
    strokeWidth: 14,
    strokeGlow: 28,
    pulseThreshold: 1.2,
  };

  let W = 0, H = 0;
  let particles = [];
  let heartPath = [];
  let stars = [];
  let formed = false;
  let pulseTimer = 0;
  let bgGradient;

  function setSize() {
    DPR = Math.max(window.devicePixelRatio || 1, 1);
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width = Math.round(W * DPR);
    canvas.height = Math.round(H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    createGradient();
    createStars();
    createHeart();
  }

  function createGradient() {
    const g = ctx.createLinearGradient(0, 0, W, H);
    g.addColorStop(0, '#ff6ec7');   // pink
    g.addColorStop(0.45, '#b05cff');// violet
    g.addColorStop(1, '#2aa1ff');   // blue
    bgGradient = g;
  }

  function createStars() {
    stars = [];
    for (let i = 0; i < CONFIG.starCount; i++) {
      stars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        r: Math.random() * 1.6 + 0.2,
        baseA: Math.random() * 0.9 + 0.1,
        speed: Math.random() * 0.008 + 0.002
      });
    }
  }

  function heartXY(t) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
    return { x, y };
  }

  function createHeart() {
    particles = [];
    heartPath = [];
    const cx = W / 2;
    const cy = H / 2;
    const step = CONFIG.step;
    const scale = CONFIG.heartScale;
    for (let a = 0; a < Math.PI * 2; a += step) {
      const p = heartXY(a);
      const tx = cx + p.x * scale;
      const ty = cy + p.y * scale;
      heartPath.push({ x: tx, y: ty });
      const startX = Math.random() * W;
      const startY = Math.random() * H;
      particles.push({
        x: startX, y: startY, tx, ty,
        size: CONFIG.particleMinSize + Math.random() * (CONFIG.particleMaxSize - CONFIG.particleMinSize),
        color: particleRedShade(),
        speed: CONFIG.speedMin + Math.random() * (CONFIG.speedMax - CONFIG.speedMin)
      });
    }
    formed = false;
    pulseTimer = 0;
  }

  function particleRedShade() {
    const light = 38 + Math.random() * 18;
    return `hsl(0, 92%, ${light}%)`;
  }

  function drawBackground() {
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, W, H);
  }

  function drawStars(time) {
    ctx.save();
    for (let s of stars) {
      const a = s.baseA * (0.6 + 0.4 * Math.sin((time * s.speed)));
      ctx.globalAlpha = a;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawHeartStroke(pulse = 0) {
    if (!heartPath.length) return;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(heartPath[0].x, heartPath[0].y);
    for (let i = 1; i < heartPath.length; i++) ctx.lineTo(heartPath[i].x, heartPath[i].y);
    ctx.closePath();
    ctx.lineWidth = CONFIG.strokeWidth + pulse * 8;
    ctx.strokeStyle = 'rgba(255,60,80,0.85)';
    ctx.shadowBlur = CONFIG.strokeGlow + pulse * 30;
    ctx.shadowColor = 'rgba(255,40,40,0.9)';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();
    ctx.lineWidth = Math.max(3, CONFIG.strokeWidth * 0.45);
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,30,30,0.95)';
    ctx.stroke();
    ctx.restore();
  }

  function updateAndDrawParticles() {
    let totalDist = 0;
    for (let p of particles) {
      const dx = p.tx - p.x;
      const dy = p.ty - p.y;
      p.x += dx * p.speed;
      p.y += dy * p.speed;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
      totalDist += Math.hypot(dx, dy);
    }
    return totalDist / particles.length;
  }

  function drawCenterText(time) {
    ctx.save();
    ctx.font = `bold ${Math.min(W, H) * 0.12}px "Segoe UI", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Red → Black gradient
    const grad = ctx.createLinearGradient(W/2 - 150, H/2, W/2 + 150, H/2);
    grad.addColorStop(0, "#ff1a1a"); // bright red
    grad.addColorStop(1, "#111");    // deep black
    ctx.fillStyle = grad;

    // Red glowing shadow
    const glow = Math.abs(Math.sin(time * 0.002)) * 40 + 40;
    ctx.shadowColor = "rgba(255,0,0,0.9)";
    ctx.shadowBlur = glow;

    ctx.fillText("ashiee!!", W / 2, H / 2);
    ctx.restore();
  }

  function animate(time = 0) {
    ctx.clearRect(0, 0, W, H);
    drawBackground();
    drawStars(time);
    const avgDist = updateAndDrawParticles();
    if (!formed && avgDist < CONFIG.pulseThreshold) {
      formed = true;
      pulseTimer = 1.0;
    }
    if (pulseTimer > 0) {
      drawHeartStroke(Math.min(1, pulseTimer));
      pulseTimer *= 0.94;
    } else {
      drawHeartStroke(Math.abs(Math.sin(time * 0.001)) * 0.12);
    }
    drawCenterText(time);
    requestAnimationFrame(animate);
  }

  canvas.addEventListener('pointerdown', () => {
    for (let p of particles) {
      p.x = Math.random() * W;
      p.y = Math.random() * H;
      p.speed = CONFIG.speedMin + Math.random() * (CONFIG.speedMax - CONFIG.speedMin);
    }
    formed = false;
    pulseTimer = 0;
  });

  window.addEventListener('resize', setSize);
  setSize();
  requestAnimationFrame(animate);
})();
</script>
</body>
</html>
